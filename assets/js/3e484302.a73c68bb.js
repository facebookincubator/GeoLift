"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1550],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),s=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=s(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},g=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),g=s(n),d=r,p=g["".concat(l,".").concat(d)]||g[d]||m[d]||a;return n?o.createElement(p,i(i({ref:t},u),{},{components:n})):o.createElement(p,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=g;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}g.displayName="MDXCreateElement"},1287:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return u},default:function(){return g}});var o=n(3117),r=n(102),a=(n(7294),n(3905)),i=["components"],c={},l="Using Commuting Zones",s={unversionedId:"GettingStarted/Incorporating_CommutingZones",id:"GettingStarted/Incorporating_CommutingZones",title:"Using Commuting Zones",description:"What are the Commuting Zones? Commuting zones are geographic areas where",source:"@site/docs/GettingStarted/Incorporating_CommutingZones.md",sourceDirName:"GettingStarted",slug:"/GettingStarted/Incorporating_CommutingZones",permalink:"/GeoLift/docs/GettingStarted/Incorporating_CommutingZones",editUrl:"https://github.com/facebookincubator/GeoLift/docs/GettingStarted/Incorporating_CommutingZones.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Common Data Errors in GeoLift",permalink:"/GeoLift/docs/GettingStarted/CommonDataErrors"},next:{title:"GeoLift Methodology",permalink:"/GeoLift/docs/Methodology/"}},u=[{value:"Installing Commuting Zones",id:"installing-commuting-zones",children:[],level:2},{value:"Using Commuting Zones in GeoLift",id:"using-commuting-zones-in-geolift",children:[],level:2}],m={toc:u};function g(e){var t=e.components,n=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"using-commuting-zones"},"Using Commuting Zones"),(0,a.kt)("p",null,"What are the Commuting Zones? Commuting zones are geographic areas where\npeople live and work and are useful for understanding local economies.\nUsing Commuting Zones instead of cities or zipcodes in GeoLift will take\nthe commuter effect into account for the geographical randomisation. For\nmore details, please visit the\n",(0,a.kt)("a",{parentName:"p",href:"https://facebookincubator.github.io/CommutingZones/docs/intro"},"documentation"),"\nof Commuting Zones"),(0,a.kt)("h2",{id:"installing-commuting-zones"},"Installing Commuting Zones"),(0,a.kt)("p",null,"Installing CommutingZones can be done directly using the remotes package\n(which is likely already installed if GeoLift is present)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-r"},'install.packages("remotes")\nremotes::install_github("facebookincubator/CommutingZones")\n')),(0,a.kt)("h2",{id:"using-commuting-zones-in-geolift"},"Using Commuting Zones in GeoLift"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-r"},'library(CommutingZones)\nlibrary(dplyr)\n\n# create input for commuting zones. country names needed to be added manually\nlocation_df <- data.frame(\n  location = unique(GeoTestData_PreTest$location),\n  country = c("United States")\n)\n\n# Get google maps API key \n# https://developers.google.com/maps/documentation/maps-static/get-api-key/\nmatched_df <- commuting_zones(\n  data = location_df,\n  location_col_name = \'location\',\n  country_col_name = \'country\',\n  gmaps_key = \'Enter Your Google Maps API Key\'\n)\n# plot the matched locations\nplot(matched_df)\n\n# transform for further GeoLift processing\nGeoTestData_PreTest_CZ <- GeoTestData_PreTest %>% \n  merge(matched_df$matched_spdf %>% \n          as.data.frame() %>% \n          select(c("location", "fbcz_id_num")), \n        by = "location", all.x = TRUE) %>% \n  group_by(.data$fbcz_id_num, .data$time) %>% \n  mutate(Y = sum(.data$Y),\n         location = paste(location, collapse = ", ")) %>% \n  distinct() %>% \n  rename(location = "fbcz_id_num", \n         location_in_cluster = "location") %>% ungroup()\n\n# treat unmatched locations\nunmatched_location <- GeoTestData_PreTest_CZ %>% \n    filter(is.na(location)) %>% \n    pull(location_in_cluster) %>% \n    unique()\ndf_unmatched <- data.frame(\n  location_in_cluster = unmatched_location,\n  location = max(GeoTestData_PreTest_CZ$location, na.rm = TRUE) + \n    seq_along(unmatched_location)\n)\nGeoTestData_PreTest_CZ <- GeoTestData_PreTest_CZ %>% \n  left_join(df_unmatched, by = "location_in_cluster") %>% \n  mutate(location = as.character(coalesce(location.y, location.x))) %>% \n  select(-location.y, -location.x)\n\n# plot pretest\nGeoPlot(GeoTestData_PreTest_CZ,\n        Y_id = "Y",\n        time_id = "time",\n        location_id = "location")\n\n# The object GeoTestData_PreTest_CZ can be used in further GeoLift functions \n# like GeoLift::GeoLiftMarketSelection(), GeoLift::GeoLiftPower() etc.\n')))}g.isMDXComponent=!0}}]);